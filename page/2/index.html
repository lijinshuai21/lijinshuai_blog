<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="李金帅">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Welcome lijinshuai&#39;s Blog"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Welcome lijinshuai&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>page - Welcome lijinshuai&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/lijinshuai_blog/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 5.4.2"></head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/lijinshuai_blog/">
                    首页
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/lijinshuai_blog/archives">
                    归档
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/lijinshuai_blog/about.html">
                    关于
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/lijinshuai_blog/tags">
                    标签
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/lijinshuai_blog/categories">
                    类别
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/lijinshuai_blog/myjob">
                    简历
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/lijinshuai_blog/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">Welcome lijinshuai's Blog</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2021/03/01/Bom/">
                BOM
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2021-03-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/JavaScript/">JavaScript</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="BOM-Broswer-Object-Model-浏览器对象模型"><a href="#BOM-Broswer-Object-Model-浏览器对象模型" class="headerlink" title="BOM Broswer Object Model (浏览器对象模型)"></a>BOM Broswer Object Model (浏览器对象模型)</h1><ul>
<li><p>BOM的主要操作浏览器，比如：创建新的页面，弹出对话框，设置定时器，检测浏览器，获取url信息等……</p>
</li>
<li><p>常见的对象有window（顶级对象）</p>
</li>
</ul>
<h1 id="以下的BOM对象都属于window的属性"><a href="#以下的BOM对象都属于window的属性" class="headerlink" title="以下的BOM对象都属于window的属性"></a>以下的BOM对象都属于window的属性</h1><ol>
<li>navigator 浏览器本身的信息。</li>
<li>location  浏览器url信息。</li>
<li>history   浏览器访问的历史。</li>
<li>screen    客户端屏幕信息。</li>
<li>document  文档对象。</li>
</ol>
<h1 id="BOM的范围更广泛，可以说DOM是BOM的一个分支。"><a href="#BOM的范围更广泛，可以说DOM是BOM的一个分支。" class="headerlink" title="BOM的范围更广泛，可以说DOM是BOM的一个分支。"></a>BOM的范围更广泛，可以说DOM是BOM的一个分支。</h1>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2021/03/01/%E9%97%AD%E5%8C%85/">
                闭包
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2021-03-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/JavaScript/">JavaScript</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="1-什么是闭包？"><a href="#1-什么是闭包？" class="headerlink" title="1. 什么是闭包？"></a>1. 什么是闭包？</h2><p>闭包就是能够读取其他函数内部变量的函数。换句话说：函数嵌套，内层函数就形成了闭包。<br>闭包简单理解成”定义在一个函数内部的函数”<br>本质上说一个函数就是一个闭包。</p>
<h2 id="2-闭包的特点？（即优缺点）？"><a href="#2-闭包的特点？（即优缺点）？" class="headerlink" title="2. 闭包的特点？（即优缺点）？"></a>2. 闭包的特点？（即优缺点）？</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>可以让函数内部的变量超出它本身的作用域在外部使用。</li>
<li>闭包可以隔离作用域。不暴露私有成员的目的，减少了变量冲突的风险。<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3> 局部变量会常驻在内存中，严重情况下会造成内存泄漏。</li>
</ol>
<h2 id="3-闭包使用场景？"><a href="#3-闭包使用场景？" class="headerlink" title="3. 闭包使用场景？"></a>3. 闭包使用场景？</h2><p>闭包主要用来找到父级函数中对应变量的值。</p>
<h2 id="4-面向过程编程思想？面向对象编程思想？-了解"><a href="#4-面向过程编程思想？面向对象编程思想？-了解" class="headerlink" title="4. 面向过程编程思想？面向对象编程思想？(了解)"></a>4. 面向过程编程思想？面向对象编程思想？(了解)</h2><p>面向过程编程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。<br>优点：解题思路明确，按步骤解决，不易出错，项目工期和成本方便控制。<br>缺点：中间某个步骤出错，有可能造成整个项目崩溃，影响太大。</p>
<p>面向对象编程是把构成问题的事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>优点：面向对象编程核心是构建各种对象。方便从全局考虑问题。<br>缺点：在构建对象时一次性考虑不全，对象属性和方法缺失。但有解决方案，可以使用继承来解决。</p>
<h2 id="闭包文档："><a href="#闭包文档：" class="headerlink" title="闭包文档："></a>闭包文档：</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43586120/article/details/89456183">https://blog.csdn.net/weixin_43586120/article/details/89456183</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sandaizi/p/11582488.html">https://www.cnblogs.com/sandaizi/p/11582488.html</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">http://www.ruanyifeng.com/blog/2012/10/javascript_module.html</a></p>
<h2 id="编程思想文档"><a href="#编程思想文档" class="headerlink" title="编程思想文档:"></a>编程思想文档:</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38638020/article/details/89318501">https://blog.csdn.net/weixin_38638020/article/details/89318501</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/9957246">https://baike.baidu.com/item/面向过程/9957246</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/24792">https://baike.baidu.com/item/面向对象程序设计/24792</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2021/02/01/js%E7%AE%80%E4%BB%8B/">
                JS发展史
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2021-02-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/JavaScript/">JavaScript</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="js发展历史"><a href="#js发展历史" class="headerlink" title="js发展历史"></a>js发展历史</h1><p>网景公司 布兰登.艾奇 10天时间搞出来了JavaScript，以前叫 LiveScript<br>后来网景公司被Sun公司收购，处于营销方面的考虑，把名字该为JavaScript。</p>
<h1 id="编程语言分为3个历史阶段"><a href="#编程语言分为3个历史阶段" class="headerlink" title="编程语言分为3个历史阶段:"></a>编程语言分为3个历史阶段:</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 机器语言：直接使用由“0”和“1”组成的二进制指令控制计算机，二进制是计算机的语言的基础。</span><br><span class="line">用计算机的语言去命令计算机干这干那，一句话，就是写出一串串由“0”和“1”组成的指令序列交由计算机执行，这种语言，就是机器语言。使用机器语言是十分痛苦的，特别是在程序有错需要修改时，更是如此。而且，由于每台计算机的指令系统往往各不相同，所以，在一台计算机上执行的程序，要想在另一台计算机上执行，必须另编程序，造成了重复工作。但由于使用的是针对特定型号计算机的语言，故而运算效率是所有语言中最高的。机器语言，是第一代计算机语言。  </span><br><span class="line"></span><br><span class="line">2. 汇编语言：把CPU指令表示为单词或单词的缩写，极大的方便了程序员对各种指令的记忆。一定程度上简化了编程复杂度，减低了学编程语言的成本。</span><br><span class="line">为了减轻使用机器语言编程的痛苦，人们进行了一种有益的改进：用一些简洁的英文字母、符号串来替代一个特定的指令的二进制串，比如，用“A D D”代表加法，“M O V”代表数据传递等等，这样一来，人们很容易读懂并理解程序在干什么，纠错及维护都变得方便了，这种程序设计语言就称为汇编语言，即第二代计算机语言。然而计算机是不认识这些符号的，这就需要一个专门的程序，专门负责将这些符号翻译成二进制数的机器语言，这种翻译程序被称为汇编程序。  </span><br><span class="line">汇编语言同样十分依赖于机器硬件，移植性不好，但效率仍十分高，针对计算机特定硬件而编制的汇编语言程序，能准确发挥计算机硬件的功能和特长，程序精炼而质量高，所以至今仍是一种常用而强有力的软件开发工具。  </span><br><span class="line"></span><br><span class="line">3. 高级语言：第三代编程语言，对CPU指令进行了高度的封装，使用更接近于人类语言的语法规则，编出的程序能在所有机器上通用。使编程复杂度和学习难度进一步降低。高级语言同样不能直接运行，需要使用编译程序将高级语言的源代码编译为汇编语言，然后才能执行。(例如c语言，某台设置只要能够运行c语言的编译器，就能够运行c语言程序)。</span><br></pre></td></tr></table></figure>

<h1 id="高级语言："><a href="#高级语言：" class="headerlink" title="高级语言："></a>高级语言：</h1><ol>
<li><p>首先，按照运行原理，分为编译型和解释型(脚本型)。<br>编译型：在程序执行之前，有一个单独的编译过程，将程序的所有源代码都编译为可执行代码（机器语言），再执行编译之后的可执行代码。(c,c++,java)<br>解释型：程序在运行的过程中：一边编译，一边执行（编译一行，执行一行）(javascript,python,php,c#)。<br>理论上，编译型语言比解释型语言执行效率高。</p>
</li>
<li><p>按照数据类型是否强制，可以分为强类型语言和弱类型语言。<br>强类型：程序中变量、参数、函数返回值，都必须指明类型，不同类型的变量不能相互赋值。(c,java,c++,c#)<br>弱类型：变量、参数、函数返回值不需要指定类型，一个变量的类型是不固定的。(js,vb)</p>
</li>
<li><p>按照编程范式，可分为面向对象语言和面向过程语言。<br>面向过程：将函数作为程序的基本单元，着重程序流程的开发。(c,js,pascal,vb)。<br>面向对象：类和对象是程序的基本单元，函数不能独立存在，着重类和对象的开发。(c++,java,objective-C)。<br>例题：把大象装进冰箱需要几步<br> 面向过程：</p>
<pre><code> 1.打开冰箱门。
 2.把大象装进冰箱。
 3.关上冰箱门。
</code></pre>
<p> 面向对象：</p>
<pre><code> 冰箱有三个功能： 1.打开冰箱门。2.把“某物”装进冰箱。3.关上冰箱门。
 告诉冰箱执行这三个功能，冰箱会自动打开门，然后把大象装进去，最后关门。
</code></pre>
</li>
<li><p>JavaScript</p>
</li>
</ol>
<ul>
<li>JS是具有函数优先的轻量级脚本语言（是一种弱类型的解释型语言，支持多范式开发“既可以面向过程也可以面向对象”）。</li>
<li>JS作为一门脚本语言，没有自己的独立运行环境，只能依附于其他的程序运行“浏览器”。直到nodeJs “js的服务器” 发布后JS才有了自己的独立运行环境，才能够操作系统功能。</li>
<li>JS的作用：实现浏览器和用户的交互以及动态样式交互 （交互：一问一答）</li>
<li>在JS眼中国页面上所有的东西都是数据“data”，在JS眼里万物万事都是对象，所以程序员天天面对对象但是找不到对象。</li>
<li>JS的兼容性问题：每个浏览器对JS的解析程度不同。</li>
</ul>
<ol start="5">
<li>JavaScript的优点和缺点<br>优点：<br> 1.使用JS可以在客户端进行数据验证，节省服务器端的资源。<br> 2.可以方便的操作各个方面的对象，使页面更加友好。<br> 3.使多种任务仅在客户端可以完成而不需要网络和服务器的参与，从而支持分布式运算和处理。<br>缺点：<br> 1.兼容性：互联网上有很多浏览器，但是各种浏览器支持JS的程度不一样，所有JS在各个浏览器上运行出来的结果会有一定差距，有时甚至会显示不出来。<br> 2.JS不能打开：读写和保存用户计算机上的文件。</li>
</ol>
<h1 id="JavaScript-和-Java-的关系"><a href="#JavaScript-和-Java-的关系" class="headerlink" title="JavaScript 和 Java 的关系"></a>JavaScript 和 Java 的关系</h1><ol>
<li>JavaScript 和 Java是两种不同的语言。他们语法上很类似 但 本质有着很大的区别。Java是比JS更加复杂的程序语言，而JS相对于Java来说很容易上手，但二者之间没有关系。</li>
<li>JS和Java的关系好比“雷锋和雷峰塔的关系”，(1995年，网景公司的布兰登.艾奇“Brendan Eich”开发的LiveScript，在sun公司收购后改名为JavaScript，原因是当时Java语言非常红火，所以借Java的名气来推广JS“但事实上除了语法类似之外没有任何关系”)。</li>
</ol>
<h1 id="ECMAScript-和-JavaScript-的关系"><a href="#ECMAScript-和-JavaScript-的关系" class="headerlink" title="ECMAScript 和 JavaScript 的关系"></a>ECMAScript 和 JavaScript 的关系</h1><h3 id="一个常见的问题是，ECMAScript-和-JavaScript-到底是什么关系？"><a href="#一个常见的问题是，ECMAScript-和-JavaScript-到底是什么关系？" class="headerlink" title="一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？"></a>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</span><br><span class="line"></span><br><span class="line">- 该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</span><br><span class="line"></span><br><span class="line">- 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。</span><br><span class="line"></span><br><span class="line">- JavaScript 在发明之初，仅仅是一个浏览器的脚本语言，本身又很多不合理，不严谨之处。随着JavaScript语言越来越流行，这些问题就更加凸显，ECMA在接手JavaScript之后，持续更新了7个版本，来修正JavaScript中的各种不合理之处。</span><br></pre></td></tr></table></figure>

<h2 id="ECMAScript-的历史"><a href="#ECMAScript-的历史" class="headerlink" title="ECMAScript 的历史"></a>ECMAScript 的历史</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ECMAScript 1.0 是 1997 年发布</span><br><span class="line">ECMAScript 2.0 是 1998 年 6 月发布</span><br><span class="line">ECMAScript 3.0 是 1999 年 12 月发布。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。</span><br><span class="line">2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。</span><br><span class="line">2009 年 12 月，ECMAScript 5.0 版正式发布。</span><br><span class="line">2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。</span><br><span class="line"></span><br><span class="line">ES5是使用最广泛的一个版本，但是ES5中还存在很多不严谨之处。后来又发布了ES6版本。</span><br><span class="line">ES6中保留了历史版本所有的特性，并添加了很多新特性。</span><br><span class="line">从 ES6 (ES2015) 开始，JavaScript 版本发布变为年更，即每年发布一个新版本，以年号标识版本，</span><br><span class="line">后续版本 ES7 (ES2016)、ES8 (ES2017)、ES9 (ES2018)、ES10(ES2019)</span><br></pre></td></tr></table></figure>

<h1 id="浏览器分为渲染引擎和js引擎"><a href="#浏览器分为渲染引擎和js引擎" class="headerlink" title="浏览器分为渲染引擎和js引擎"></a>浏览器分为渲染引擎和js引擎</h1><ol>
<li>渲染引擎（也就是浏览器内核），用来解析html 和 css。</li>
<li>js引擎（解释器）解析js代码。</li>
</ol>
<h1 id="js的组成"><a href="#js的组成" class="headerlink" title="js的组成"></a>js的组成</h1><ol>
<li>js基础语法</li>
<li>DOM对象模型 /文档对象模型（DOM：Document Object Model）</li>
<li>BOM对象模型 /浏览器对象模型（B:Broswer Object Model）</li>
</ol>
<h1 id="HTML-CSS-和-JavaScript的关系"><a href="#HTML-CSS-和-JavaScript的关系" class="headerlink" title="HTML,CSS 和 JavaScript的关系"></a>HTML,CSS 和 JavaScript的关系</h1><ol>
<li>HTML决定了页面上的内容（用户看到的内容“标签”）。</li>
<li>CSS决定了页面中内容的样式（对页面的美化）。</li>
<li>JavaScript决定了页面的事务逻辑（添加交互，动态效果）。</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2020/07/01/cookie%E7%9A%84%E7%AE%80%E4%BB%8B/">
                Cookie内存
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-07-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/计算机/">计算机</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="cookie-的作用"><a href="#cookie-的作用" class="headerlink" title="cookie 的作用"></a>cookie 的作用</h1><p>记录用户的状态，由于HTTP是无状态的协议。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如：张三去丹尼斯购物，首次购物丹尼斯收银员并不认识张三“并且以后张三再次来丹尼斯购物收银员也不会认识他”，为了下次来购物有优惠所以在丹尼斯给张三办了一张会员卡“下次张三再来购物出示会员即可享受会员优惠”。</span><br><span class="line"></span><br><span class="line">cookie : 会员卡</span><br></pre></td></tr></table></figure>

<h1 id="cookie工作原理"><a href="#cookie工作原理" class="headerlink" title="cookie工作原理"></a>cookie工作原理</h1><ol>
<li><p>浏览器第一次给服务器发送请求时，服务器不知道浏览器的身份，所以服务器会创建一个身份标识（cookie：key=value），服务器响应浏览器时会携带者cookie一同发送给浏览器。</p>
</li>
<li><p>浏览器接收到响应后，会将cookie保存起来，等到下一次发送请求时，会携带cookie发送给服务器。</p>
</li>
<li><p>服务器接收到请求之后，会发现cookie并进行验证，如果验证成功就长长响应浏览器发送的请求。</p>
</li>
</ol>
<p><strong>cookie是存储在浏览器端的</strong></p>
<h1 id="cookie-分为"><a href="#cookie-分为" class="headerlink" title="cookie 分为"></a>cookie 分为</h1><ul>
<li>会话cookie ：没有设置到期时间，会随着浏览器的关闭而删除。</li>
<li>持久性cookie ：设置到期时间，会依据到期时间而删除cookie。</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2020/06/01/3-5%20%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/">
                网络，服务器，IP,请求
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-06-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/HTTP/">HTTP</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>网址：URL，uniform resource location,统一资源定位符；</p>
<p>http: hypertext transform protocol ; 超文本传输协议；定义了网络上传输数据的规范。客户端主动请求，服务器被动响应;短连接;</p>
<p>客户端：用户使用的计算机设备，这些设备上安装的软件; </p>
<p>​        前端开发工程师:  js</p>
<p>​        android开发工程师： java </p>
<p>​        iOS开发工程师：oc \ swift </p>
<p>服务器：也是计算机设备；与用户使用的计算机相比，存储容量更大、效率更高、安全性更高； 服务器上安装的软件，也简称为服务器。</p>
<p>​    java 、 php  、 .net 、 nodejs  、 python、go</p>
<p>域名：domain name ; 采用域名是为了方便记忆，域名是需要转化为Ip使用的。</p>
<p>域名解析系统：DNS, domain name system ;将域名转化为IP。</p>
<p>ip:同一网络下，联网设备的唯一标识符。</p>
<p>ipV4地址 :32个二进制位表示;  点分十进制；2^32 ; </p>
<p>192.168.1.196 </p>
<p>ipV6地址：128个二进制表示;  2^128;</p>
<p>CDCD:910A:2222:5498:8475:1111:3900:2020 ;  </p>
<p>资源路径 ：  <a target="_blank" rel="noopener" href="https://news.cctv.com/special/2021lianghui/live13/index.shtml">https://news.cctv.com/special/2021lianghui/live13/index.shtml</a>   其中news.cctv.com是域名；之后/special/2021lianghui/live13/index.shtml是资源路径  ；  <a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com/</a>  没有说明资源路径的，一般是给默认资源（默认文档）,默认文档一般都是 index.html\ index.jsp\default.html…..</p>
<p>查询字符串:<a target="_blank" rel="noopener" href="https://common.vip.com/?type=sidebar&amp;jq=0&amp;core=0&amp;v=132">https://common.vip.com/?type=sidebar&amp;jq=0&amp;core=0&amp;v=132</a>  其中？后面的type=sidebar&amp;jq=0&amp;core=0&amp;v=132是查询字符串(query string) ； 是请求资源时，携带的数据信息。</p>
<p>​    1、请求：request ; </p>
<p>请求行：请求方式，资源路径，协议\版本;</p>
<p>​        请求方式：</p>
<p>​                GET  ： 一般用于从服务器获取资源;</p>
<p>​                POST :  一般用于向服务器发送资源;</p>
<p>​                PUT: 一般用于修改服务器现有数据; </p>
<p>​                DELETE: 一般用于删除服务器上某项资源;</p>
<p>请求头： request header ;  包含一些key-value键值对；例如</p>
<p>​        accept : 认可; 说明想要什么类型的资源; </p>
<p>​        accept-language: 说明想要资源的语言类型;</p>
<p>​        accept-encoding：说明支持的编码(压缩)方式;</p>
<p>​        connection：连接 ；  基于http协议进行网络通信，第一步是客户端和服务器建立连接； 第二步，浏览器发请求；第三步，服务器接到请求，进行请求解析，进行响应；第四步，请求和响应结束后，会断开连接。这是http协议的一大特点，短连接。之后进行下一次请求，需要再次重新建立连接。当connection的取值为keep-alive(保持活的)时，一次请求-响应结束后，连接不会立即断开，会保留极短时间，在这段时间内，不需要重新建立连接，可以直接基于现有连接发请求。</p>
<p>​        user-agent：用户代理；说明当前用户设备的一些信息。</p>
<p>​        host:主人；服务器主机地址;</p>
<p>请求体：携带的数据;</p>
<p>2、响应：response ;</p>
<p>响应行： 协议\版本   状态码   状态信息</p>
<p>​        状态码：说明当前请求的状态；不同状态码，代表不同含义;</p>
<p>​                200  OK : 说明请求成功了;</p>
<p>​                404 Not Found : 请求资源找不到; </p>
<p>​                304 Not Modified: 在上次请求后，该资源未被修改;  使用的是缓存；</p>
<p>​                501、503：服务器出问题了;  </p>
<p>响应头：</p>
<p>​    content-type:内容类型；服务器返回资源类型;</p>
<p>​    Date:日期；服务器做出响应的日期;</p>
<p>​    Expires:有效期; </p>
<p>​    Server:服务器；    </p>
<p>响应体： 响应数据。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2020/06/01/DOM/">
                DOM
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-06-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/Javascript/">Javascript</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="认识DOM"><a href="#认识DOM" class="headerlink" title="认识DOM"></a>认识DOM</h1><ul>
<li>DOM:Document Object Model”文档对象模型”。</li>
<li>DOM适用于HTML的应用程序接口API，用来操作标签的。</li>
</ul>
<h1 id="DOM的作用"><a href="#DOM的作用" class="headerlink" title="DOM的作用"></a>DOM的作用</h1><ul>
<li>能够改变页面中所有的HTML元素“标签及内容”。</li>
<li>能够改变页面中所有的HTML属性“标签内的属性”。</li>
<li>能够改变页面中所有的CSS属性“样式”。</li>
<li>能过对页面中所有的事件作出反应。</li>
</ul>
<h1 id="节点的name，type，value"><a href="#节点的name，type，value" class="headerlink" title="节点的name，type，value"></a>节点的name，type，value</h1><ol>
<li><p>HTML文档中所有的事物都是DOM节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.1 HTML中所有的元素称为 元素节点</span><br><span class="line">1.2 HTML中所有的属性称为 属性节点</span><br><span class="line">1.3 HTML中所有的文本称为 文本节点</span><br><span class="line">1.4 HTML中所有的注释称为 注释节点</span><br><span class="line">1.5 HTML中的文档本身称为 文档节点（根节点)</span><br><span class="line">1.6 HTML文档中的空格或换行也是节点 文本节点</span><br></pre></td></tr></table></figure></li>
<li><p>nodeName属性是获取某一个节点的节点名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.1 元素节点的nodeName 和元素名一样(大写)</span><br><span class="line">2.2 属性节点的nodeName 和元素属性名一样</span><br><span class="line">2.3 文本节点的nodeName #text</span><br><span class="line">2.4 注释节点的nodeName #comment</span><br><span class="line">2.5 文档节点的nodeName #document</span><br></pre></td></tr></table></figure></li>
<li><p>nodeType，获取某个节点的节点新型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">3.1 元素节点的nodeType node.element.node(大写)</span><br><span class="line">3.2 属性节点的nodeType node.attribute.node(大写)</span><br><span class="line">3.3 文本节点的nodeType node.text.node(大写)</span><br><span class="line">3.4 注释节点的nodeType node.comment.node(大写)</span><br><span class="line">3.5 文档节点的nodeType node.document.node(大写)</span><br><span class="line"></span><br><span class="line">3.6    nodeType == 1  ： 元素节点</span><br><span class="line">扩     nodeType == 2  ： 属性节点</span><br><span class="line">展     nodeType == 3  ： 文本节点</span><br><span class="line">       注释 comments   8</span><br><span class="line">       文档 document   9</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>nodeValue，获取某个节点的节点值，一般用于文本节点和属性节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.1 对于文本节点的nodeValue 属性包含文本</span><br><span class="line">4.2 对于属性节点nodeValue 属性包含属性值</span><br><span class="line">4.3 nodeValue对于文档及节点和元素节点是不可用的，使用textCotent代替nodeValue来获取元素节点的内容。</span><br></pre></td></tr></table></figure></li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2020/06/01/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
                内存管理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-06-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/计算机/">计算机</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="什么是内存"><a href="#什么是内存" class="headerlink" title="什么是内存"></a>什么是内存</h1><p>JS中是在创建变量，对象，字符串等时自动进行分配内存，并且在不使用他们的时候“自动”释放，释放的过程叫做“垃圾回收”。</p>
<h1 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h1><ul>
<li>内存分配：当我们声明变量，函数，对象时，系统会自动为他们分配内存。</li>
<li>内存使用：读写内存，就是使用变量，函数等。</li>
<li>内存释放：使用完毕，由垃圾回收机制自动回收使用的内存。</li>
</ul>
<h1 id="内存的概念"><a href="#内存的概念" class="headerlink" title="内存的概念"></a>内存的概念</h1><p>在硬件层面，计算机内存是由大量的触发器)组成的。每一个触发器都包含有一些晶体管，能够存储1比特。单个触发器可通过一个唯一标识符来寻址，这样我们就可以读和写了。因此从概念上讲，我们可以把计算机内存看作是一个巨大的比特数组，我们可以对它进行读和写。<br>有很多东西都存储在内存中：</p>
<ol>
<li>所有被程序使用的变量和其他数据</li>
<li>程序的代码，包括操作系统自身的代码<br>当你编译你的代码时，编译器可以检查原始的数据类型并且提前计算出将会需要多少内存。然后把所需的（内存）容量分配给调用栈空间中的程序。这些变量因为函数被调用而分配到的空间被称为堆栈空间，它们的内存增加在现存的内存上面（累加）。如它们不再被需要就会按照 LIFO（后进，先出）的顺序被移除。</li>
</ol>
<h1 id="JS内存的分配"><a href="#JS内存的分配" class="headerlink" title="JS内存的分配"></a>JS内存的分配</h1><p>JS一般在定义变量时就完成内存分配。</p>
<h1 id="JS使用内存"><a href="#JS使用内存" class="headerlink" title="JS使用内存"></a>JS使用内存</h1><p>在JS中使用分配的内存，就是“读写变量的值 或 对象的属性，或给函数传参”</p>
<h1 id="JS内存回收"><a href="#JS内存回收" class="headerlink" title="JS内存回收"></a>JS内存回收</h1><p>当内存不再需要的时候需要释放掉<br>大部分的内存管理问题出现在这个阶段（这里最难的任务是指出在什么时候分配的内存不再被需要，这通常要开发者来决定程序中的哪一块内存不再被需要了，并释放）。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><ul>
<li><p>引用计数垃圾回收<br>最初的垃圾回收算法，“内存不再使用”，看内存中是否有指向它的引用。</p>
</li>
<li><p>标记清除算法<br>标记清除将“不再使用的对象”定义为“无法达到的对象”。就是从根部出发定时扫描内存中的对象“但凡能从根部代打的对象都是需要使用的”无法从根部出发触及到对象被标记为不再使用“稍后进行回收”。</p>
</li>
</ul>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ol>
<li>意外的全局变量<br>JS处理未定义变量的方式比较松“未定义的变量会在全对象创建一个新的变量在浏览器中”</li>
</ol>
<ul>
<li>解决方法：使用严格模式，在文件头部添加’use strict’</li>
</ul>
<ol start="2">
<li><p>没有释放的计时器或回调函数</p>
</li>
<li><p>脱离DOM的引用</p>
</li>
<li><p>闭包</p>
</li>
</ol>
<h1 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h1><ul>
<li>不用的东西及时归还</li>
</ul>
<ol>
<li>减少不必要的全局变量，使用严格模式避免意外创建全局对象。</li>
<li>在使用完数据后，及时解除引用（闭包中的变量，dom的引用，定时器清除）</li>
<li>组织好你的逻辑，避免死循环等造成的浏览器卡顿，崩溃问题。</li>
</ol>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><ul>
<li>可执行的代码段 </li>
</ul>
<ol>
<li>全局执行上下文：不在任何函数中的代码，只有一个，this全部指向window。</li>
<li>函数执行上下文：只有调用函数才会为该函数创建一个新的执行上下文，可以有多个。</li>
<li>Eval函数执行上下文：不建议使用。</li>
</ol>
<p>-执行上下文的生命周期</p>
<ol>
<li>创建阶段</li>
<li>执行阶段</li>
<li>回收阶段 (执行完毕后执行上下文会出 栈 等待垃圾回收);</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2020/06/01/%E4%B8%80%E6%AC%A1HTTP%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/">
                HTTP请求响应
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-06-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/HTTP/">HTTP</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="一次HTTP请求响应的完整过程"><a href="#一次HTTP请求响应的完整过程" class="headerlink" title="一次HTTP请求响应的完整过程"></a>一次HTTP请求响应的完整过程</h1><p>一次HTTP请求响应的完整过程</p>
<p>​    1、HTTP协议http协议特点无连接指的是什么？无状态指的是什么？</p>
<p>​    2、http协议工作流程</p>
<p>​    3、请求get\post异同：get请求缓存涉及问题：禁止浏览器缓存数据网上常见的解决方案post请求比get请求更安全？</p>
<p>​    4、响应Http状态码</p>
<p>​    5、网络七层协议</p>
<p>​    6、TCP三次握手四次分手TCP三次握手 (tcp:transform control protocol,传输控制协议，传输层协议；http协议是基于tcp/ip协议的)为什么要三次握手TCP四次分手为什么要四次分手</p>
<p> 1、HTTP协议 </p>
<p>HTTP协议：Hyper Text Transfer Protocol，超文本传输协议，是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型；是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。</p>
<p> http协议特点 </p>
<p>1.支持客户/服务器模式。</p>
<p>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径、请求数据。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。</p>
<p>4.无(短)连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p> 无连接指的是什么？ </p>
<p>无连接是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。因此 HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。</p>
<p>随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，Keep-Alive 被提出用来解决这效率低的问题。</p>
<p> Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。市场上的大部分 Web 服务器，包括 iPlanet、IIS 和 Apache，都支持 HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep-Alive 功能对资源利用的影响尤其突出。 </p>
<p>这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。</p>
<p> 无状态指的是什么？ </p>
<p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。</p>
<p>HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。</p>
<p>缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。</p>
<p>客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP 无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session，另现在用的比较多的是token。</p>
<p>Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了（当然，不排除用户手工删除Cookie）。而还有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私。</p>
<p>Cookies 最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是 Cookies 的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入 Cookies，以便在最后付款时提取信息。</p>
<p>与 Cookie 相对的一个解决方案是 Session，它是通过服务器来保持状态的。</p>
<p>当客户端访问服务器时，服务器根据需求设置 Session，将会话信息保存在服务器上，同时将标示 Session 的 SessionId 传递给客户端浏览器，浏览器将这个 SessionId 保存在内存中，我们称之为无过期时间的 Cookie。浏览器关闭后，这个 Cookie 就会被清掉，它不会存在于用户的 Cookie 临时文件。</p>
<p>以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个 SessionId，就能取得客户端的数据信息。</p>
<p>如果客户端浏览器意外关闭，服务器保存的 Session 数据不是立即释放，此时数据还会存在，只要我们知道那个 SessionId，就可以继续通过请求获得此 Session 的信息，因为此时后台的 Session 还存在，当然我们可以设置一个 Session 超时时间，一旦超过规定时间没有客户端请求时，服务器就会清除对应 SessionId 的 Session 信息。</p>
<p> 2、http协议工作流程 </p>
<p>一次HTTP操作称为一个事务，其工作过程大概如下：</p>
<p>1用户在浏览器中传入需要访问网页的URL或者点击某个网页中链接；</p>
<p>2浏览器根据URL中的域名，通过DNS解析出目标网页的IP地址；</p>
<p>3在HTTP开始工作前，客户端首先会通过TCP/IP协议来和服务端建立链接（TCP三次握手）</p>
<p>4建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能内容。</p>
<p>5服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<p>6一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接。如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 </p>
<p> 3、请求 </p>
<p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p>
<p>请求行（request line）、请求头（header）、请求体组成。</p>
<p> get\post异同： </p>
<table>
<thead>
<tr>
<th>操作</th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>后退按钮/刷新</td>
<td>无害</td>
<td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td>
</tr>
<tr>
<td>书签</td>
<td>可收藏为书签</td>
<td>不可收藏为书签</td>
</tr>
<tr>
<td>缓存</td>
<td>能被缓存</td>
<td>不能缓存</td>
</tr>
<tr>
<td>编码类型</td>
<td>application/x-www-form-urlencoded</td>
<td>application/x-www-form-urlencoded 或 multipart/form-data或者application/json。为二进制数据使用多重编码。</td>
</tr>
<tr>
<td>历史</td>
<td>参数保留在浏览器历史中。</td>
<td>参数不会保存在浏览器历史中。</td>
</tr>
<tr>
<td>对数据长度的限制</td>
<td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td>
<td>无限制。</td>
</tr>
<tr>
<td>对数据类型的限制</td>
<td>只允许 ASCII 字符。</td>
<td>没有限制。也允许二进制数据。</td>
</tr>
<tr>
<td>安全性</td>
<td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td>
<td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td>
</tr>
<tr>
<td>可见性</td>
<td>数据在 URL 中对所有人都是可见的。</td>
<td>数据不会显示在 URL 中。</td>
</tr>
</tbody></table>
<p> get请求缓存涉及问题： </p>
<p>​    关于get请求，不同浏览器间产生不同的问题，想必很多前端开发人员都遇到过。</p>
<p>​    常见的是ajax请求过一次以后，以后的相同 url 的 get 请求：</p>
<p>case 1 有时返回304，有时返回200;</p>
<p>case 2 有时无论后台数据是否变化始终返回304，有时却始终返回200；</p>
<p>同一套代码在不同浏览器间结果不同；</p>
<p> 禁止浏览器缓存数据网上常见的解决方案 </p>
<p>​    1.在html页面设置Meta标签</p>
<meta http-equiv="Cache-Control" content="no-store"/>  

<meta http-equiv="Pragma" content="no-cache"/>  

<meta http-equiv="Expires" content="0"/>  

<p> 结果：因浏览器不同或者同一浏览器间版本不同，这个方法有很大的兼容性，很多时候根本没有作用。</p>
<p><strong>2</strong>在ajax的 URL 参数后面加时间戳或者随机数</p>
<p>$.ajax({</p>
<p>  url: ‘<a target="_blank" rel="noopener" href="http://localhost/api/list&#39;">http://localhost/api/list&#39;</a>,</p>
<p>  type: ‘get’,</p>
<p>  data: {</p>
<p>   _t: new Date().valueOf() //加时间戳</p>
<p>  //_t: Math.random() 加随机数</p>
<p>  },</p>
<p>  success: function ( res ) {</p>
<p>   console.log(res);</p>
<p>  }</p>
<p>})</p>
<p>//  <a target="_blank" rel="noopener" href="http://localhost/api/list?time=1234567890">http://localhost/api/list?time=1234567890</a></p>
<p>结果：这种方式虽然能解决IE始终返回304的问题，但实际上每个ajax都会去请求服务器，对web优化并非最佳的解决方案。</p>
<p><strong>3</strong>用post请求替代get请求</p>
<p>结果： 不推荐，一是因为这种做法不符合RESTful API设计，二是因为这种方式同样会每次请求服务器，没有真正利用到浏览器自带的缓存功能。</p>
<p>restful api：</p>
<p>  get:获取数据</p>
<p>  post：发送数据</p>
<p>  put：更新数据</p>
<p>  delete：删除数据</p>
<p> post请求比get请求更安全？ </p>
<p>我们常听到GET不如POST安全，因为POST用body传输数据，而GET用url传输，更加容易看到。但是从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。</p>
<p>为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是https——即用SSL协议协商出的密钥加密明文的http数据。这个加密的协议和HTTP协议本身相互独立。如果是利用HTTP开发公网的站点/App，要保证安全，https是最最基本的要求。</p>
<p>数据加密：md5、desc…….</p>
<p> 4、响应 </p>
<p>HTTP响应组成：响应行、响应头、响应体。</p>
<p>响应行</p>
<p>   （HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>
<p>响应头</p>
<p>   Date:生成响应的日期和时间；</p>
<p>   Content-Type:指定了MIME类型的HTML(text/html)</p>
<p> Http状态码 </p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational(信息性状态码)</td>
</tr>
<tr>
<td>2XX</td>
<td>Success(成功状态码)</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection(重定向)</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error(客户端错误状态码)</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error(服务器错误状态吗)</td>
</tr>
</tbody></table>
<p> 5、网络七层协议 </p>
<p>OSI 模型(Open System Interconnection model)是一个由国际标准化组织􏰁提出的概念模型,试图􏰁供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。它将计算机网络体系结构划分为七层,每层都可以􏰁供抽象良好的接口。了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议。OSI 模型各层间关系和通讯时的数据流向如图所示：</p>
<p>常见的应用层协议：</p>
<p> 6、TCP三次握手四次分手 </p>
<p> TCP三次握手 (tcp:transform control protocol,传输控制协议，传输层协议；http协议是基于tcp/ip协议的) </p>
<p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。</p>
<p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
<p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<p> 为什么要三次握手 </p>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<p> TCP四次分手 </p>
<p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>
<p>TCP的四次挥手</p>
<p>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p>
<p>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p>
<p>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p>
<p>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p>
<p> 为什么要四次分手 </p>
<p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2020/05/01/Ajax/">
                AJAX,GET,POST
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-05-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/AJAX/">AJAX</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="一，什么是AJAX？"><a href="#一，什么是AJAX？" class="headerlink" title="一，什么是AJAX？"></a>一，什么是AJAX？</h1><p>AJAX 是 异步 JavaScript 和 XML，全称(Asynchronous JavaScipt And XML).<br>是一种创建交互式，快速动态网页应用的网页开发技术，无需要重新加载整个网页的情况下，能够更新部分网页的技术。</p>
<ul>
<li>AJAX是一种交互技术。（客户端和服务器之间的交互）</li>
<li>AJAX天生是异步的，不会阻塞，用户体验好。</li>
<li>缺点：不能进行回退(不会操作历史记录)。</li>
<li>AJAX不是新的编程语言，而是一种使用现有的标准的新方法</li>
</ul>
<h3 id="AJAX基于现有的Internet标准"><a href="#AJAX基于现有的Internet标准" class="headerlink" title="AJAX基于现有的Internet标准"></a>AJAX基于现有的Internet标准</h3><ul>
<li>XMLHttpRequest对象（异步与服务器交换数据）</li>
<li>JS/DOM （信息显示/交互） CSS（给数据定义样式）  XML&amp;JSON（作为转换数据的方式）</li>
</ul>
<p>XML:可扩展的标记语言，可以认为HTML是XML的子集（不准确）。<br>xml主要用来传输数据的，是一种数据交换格式，原来webService中使用，后面再介绍一种数据交换格式JSON。主要用来渲染数据</p>
<h1 id="HTTP请求与相应的组成："><a href="#HTTP请求与相应的组成：" class="headerlink" title="HTTP请求与相应的组成："></a>HTTP请求与相应的组成：</h1><ul>
<li>RequestHeaders：HTTP请求头信息，用来描述一些元数据</li>
<li>HTTP请求体。也就是请求的正文</li>
<li>ResponseHeaders：HTTP响应头信息，用来描述一些元数据</li>
<li>HTTP响应体，也就是响应的正文</li>
</ul>
<h1 id="HHTP请求方法："><a href="#HHTP请求方法：" class="headerlink" title="HHTP请求方法："></a>HHTP请求方法：</h1><p>   <strong>GET</strong>：常用语向服务器查询某些信息，必要时，可以将查询字符串参数追加到UTL末尾，以便将信息发送给服务器。<br>   <strong>POST</strong>：常用于指定资源提交数据进行处理请求(例如提交表单或者上传文件)，数据被包含在请求体中(body体)。请求可能会导致新的资源的建立或已有的资源的修改。</p>
<h1 id="响应状态码："><a href="#响应状态码：" class="headerlink" title="响应状态码："></a>响应状态码：</h1><ul>
<li>它以“清晰明确”的语言告诉客户端(浏览器)本次请求的处理结果，一般由3位数字代码组成。<h3 id="HTTP状态码："><a href="#HTTP状态码：" class="headerlink" title="HTTP状态码："></a>HTTP状态码：</h3></li>
<li>1XX 接收信息正在处理</li>
<li>2XX 正常处理完毕 （200 ok请求成功）</li>
<li>3XX 附加操作  （301 永久重定向。 302 临时重定向）</li>
<li>4XX 无法处理  （400 语法错误。 401 未认证。 403 禁止访问。404 资源未找到）</li>
<li>5XX 请求出错  （500 服务器故障。503服务器繁忙）</li>
</ul>
<h1 id="请求的过程"><a href="#请求的过程" class="headerlink" title="请求的过程"></a>请求的过程</h1><ol>
<li>web ：页面的内容及数据展示</li>
<li>数据库 ：管理的数据仓库“管理大量的数据”</li>
<li>nodeJS：后端服务器，向前端提供需要显示在网页内容的数据</li>
</ol>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><pre><code>- 前端 : 没办法和数据库直接通信，前端发起请求
- 后端 ：请求来到后端的程序文件中，通过后端的逻辑处理去到数据库”操作数据库，获取操作结果“
- 数据库 ： 数据库返回操作的结果，把结果响应给前端进行展示
</code></pre>
<h1 id="AJAX技术"><a href="#AJAX技术" class="headerlink" title="AJAX技术"></a>AJAX技术</h1><ul>
<li>Ajax即 Asynchronous Javascript And XML(异步JavaScript 和 XML)，是指一种创建交互式，快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。</li>
<li>通过与后台与服务器进行少量数据交换，Ajax可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</li>
<li>局部刷新技术：部分网页内容进行刷新(例如:下拉刷新列表，上拉加载更多列表，用户名是否被注册，地图“放大局部时加载数据”，等……)，不用刷新整个网页</li>
<li>异步：Ajax在http响应没有结束的时候，可以继续进行后续操作，从而提高用户体验。</li>
</ul>
<h1 id="KOA框架搭建后端环境"><a href="#KOA框架搭建后端环境" class="headerlink" title="KOA框架搭建后端环境"></a>KOA框架搭建后端环境</h1><p>原因：前端不能直接操作数据库，得通过先访问后端，通过后端操作数据库 </p>
<p>选择使用nodeJS作为后端环境，因为nodeJS的底层语言也是JS“使用方便，易懂”</p>
<p>Ajax主要是是前后端进行通信交互的技术，先不涉及数据库</p>
<p>KOA：基于Node.js平台的下一代web框架“利用koa可以快速搭建一个web后台环境”</p>
<p>koa环境搭建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 安装Node.js  ,10以上的版本就行</span><br><span class="line">2. 安装脚手架：npm i -g koa-generator    </span><br><span class="line">3. 安装成功后输入命令 koa2 qqsports    (koa2是koa第2版本，qqsports是文件名)，创建一个项目文件夹(创建一些初始的代码)</span><br><span class="line">4. 输入命令 cd qqsports   进入文件夹</span><br><span class="line">5. 输入命令 npm i  安装依赖</span><br><span class="line">6. 输入命令  npm run dev  来启动koa框架</span><br><span class="line">7. 打开浏览器再地址栏输入  localhost:3000  （页面出现hello koa2，说明运行成功）</span><br><span class="line">8. 走到这一步说明我们已经拥有了一个后端环境，端口号是localhost ，域名是3000   </span><br><span class="line">9. &quot;http://localhost:3000&quot; 访问koa2应用</span><br><span class="line">10. 访问资源：在public目录下有3个文件夹(是脚手架自己创建的)，可以随意的在此目录下放资源，我们可以通过我们的url访问到。</span><br><span class="line">	例如：在public文件的image文件中放入一张图片，在地址栏“localhost:3000/images/图片名“，查看图片。</span><br><span class="line">		 在public文件内添加一个html文件在地址栏”localhost:3000/文件名”，运行文件。</span><br></pre></td></tr></table></figure>

<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>概念：如何定义应用的端口及如何响应客户端的请求“也就是说我们浏览器发起一个请求到我们的服务器上面，其实呢就是先要保证有一个请求地址也就是我们的url，而这个url也就是路由,在koa框架中路由系统已经被搭建好在文件的routes文件中”</p>
<p>总结：<br>    KOA框架：快速搭建一个后端环境，这样后端可以编写相关代码，前端也能发起各种http请求。<br>    KOA框架是基于Node.js开发的，而Node.js只是作为后端执行环境使用“Node.js后端语言是JS”</p>
<h1 id="Ajax的基本框架"><a href="#Ajax的基本框架" class="headerlink" title="Ajax的基本框架"></a>Ajax的基本框架</h1><h3 id="创建XMLHttpRequest"><a href="#创建XMLHttpRequest" class="headerlink" title="创建XMLHttpRequest"></a>创建XMLHttpRequest</h3><p>Ajax通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。XMLHTTPRequest对象是Ajax的主要接口，用于浏览器与服务器之间的通信</p>
<ol>
<li><p>创建,实例化xhr对象<br> var xhr = new XMLHTTPRequest();</p>
</li>
<li><p>xhr实例下的load事件，用来监听请求是否已经成功完成<br> xhr. onload =  function( ){ console.log(‘请求已经完成’) ；}</p>
</li>
<li><p>发出HTTP请求<br> xhr实例创建成功后，使用open() 和 send() 方法发出HTTP请求<br> open:连接 ，参数1请求的方式，参数2请求的url，参数3是否异步true异步false异步“可省略默认值为true”<br> send:发送数据<br> xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://localhost/list&#39;,&#39;true&#39;">http://localhost/list&#39;,&#39;true&#39;</a>)<br> xhr.send()</p>
</li>
<li><p>去routes的index.js文件中编写一下list路由<br> // 根据上面变写<br> // ctx 是表示执行上下文，它包含请求对象和响应对象<br> router.get(‘/list’, async (ctx, next)=&gt;{</p>
<pre><code> //随便返回一个字符串测试

   ctx.body = &quot;list Data&quot;;
</code></pre>
<p>   })</p>
</li>
<li><p>刷新浏览器，在控制台查看请求状态“输出结果，查看list状态码，response响应的结果”</p>
</li>
<li><p>发送POST请求，发送请求方式相同把GET改为POST</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本框架，步骤1：创建xhr对象 “所有的Ajax操作都是通过这个实例来完成的”<br>基本框架，步骤2：监听请求是否完成 “onload触发代表请求完成，可以在事件函数中操作，比如页面的渲染工作”<br>基本框架，步骤3：发出HTTP请求  “在浏览器端如何发送一个HTTP请求访问指定的服务端，通过xhr的open方法连接 和 send方法发送”</p>
<h1 id="请求操作"><a href="#请求操作" class="headerlink" title="请求操作"></a>请求操作</h1><h3 id="GET发送数据"><a href="#GET发送数据" class="headerlink" title="GET发送数据"></a>GET发送数据</h3><p>原理：GET请求通过哦查询字符串参数的方式把请求体内容传输给后端，要求通过附加url后面进行传输。<br>xhr.open(‘GET’,’<a target="_blank" rel="noopener" href="http://localhost/list?type=phone&amp;count=20&#39;,true">http://localhost/list?type=phone&amp;count=20&#39;,true</a>)<br>xhr.send();<br>演示：<br>html文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// GET请求传输数据</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onload = function()&#123;</span><br><span class="line">        console.log(&quot;请求完成&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(&#x27;GET&#x27;,&#x27;/list?type=phone&amp;count=20&#x27;,true);</span><br><span class="line">    xhr.send();</span><br></pre></td></tr></table></figure>

<p>接口文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#x27;/list&#x27;, async (ctx, next)=&gt;&#123;</span><br><span class="line">	// 接收get传输的数据</span><br><span class="line">  	// 通过ctx下面有一个request对象的query</span><br><span class="line">  		console.log(ctx.request.query);</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220709101040068.png"></p>
<p>通过命令行窗口，koa框架会把发过来的查询字符换进行解析，解析为对象的格式<br><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220709101240646.png"></p>
<h3 id="POST发送数据"><a href="#POST发送数据" class="headerlink" title="POST发送数据"></a>POST发送数据</h3><p>POST请求默认通过纯文本的方式把请求体内容传给后端，要求通过send()方法参数进行传输<br>xhr.open(‘POST’,’<a target="_blank" rel="noopener" href="http://localhost/register&#39;,true">http://localhost/register&#39;,true</a>);<br>xhr.send(‘James’); //方法内是纯文本数据<br>但是前后端交互不建议使用纯文本，还是推荐使用key，value组合的方式发送数据。<br>POST如果想发送key，value组合的数据可以通过 “名称/值”对的方式吧请求体内容穿给后端，要求通过    setRequestHeader()方法进行设置<br>    xhr.open(‘OPST’,’<a target="_blank" rel="noopener" href="http://localhost/register&#39;,true">http://localhost/register&#39;,true</a>);<br>    xhr.setRequestHeader(‘Content-Type’,’application/x-www-form-urlencoded’);<br>    xhr.send(‘username=James&amp;password=123456’);<br>演示：<br>html文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// POST请求传输数据</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onload = function()&#123;</span><br><span class="line">        console.log(&quot;请求完成&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(&#x27;POST&#x27;,&#x27;/list2&#x27;,true);</span><br><span class="line">    xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;)</span><br><span class="line">    xhr.send(&#x27;username=James&amp;password=123456&#x27;);</span><br></pre></td></tr></table></figure>

<p>接口文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// post请求</span><br><span class="line">	router.post(&#x27;/list2&#x27;, async (ctx, next)=&gt;&#123;</span><br><span class="line">  		ctx.body = &quot;list2 Data&quot;;</span><br><span class="line">  		// 接收post传输的数据</span><br><span class="line">  		// 通过ctx下面有一个request对象的body</span><br><span class="line">  		console.log(ctx.request.body);</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p>打开浏览器发送请求，数据通过请求体查看内容，在终端中查看返回的数据。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>GET发送数据：url?后面，通过查询字符串参数形式发送。<br>POST发送数据：send()方法参数，类型为纯文本，转换为“名称/值”对 或 文件 或 JSON等。</p>
<h1 id="Ajax的响应操作"><a href="#Ajax的响应操作" class="headerlink" title="Ajax的响应操作"></a>Ajax的响应操作</h1><p>status是XMLHttpRequest对象的一个属性，表示响应的HTTP状态码</p>
<p>responseText响应字符串<br>返回从服务器接收到的字符产，该属性为只读。只有HTTP请求完成接收后，该属性才会包含完整的数据。<br>例如：<br>    if(xhr.status == 200){<br>            console.log(xhr.responseText)<br>    }<br>演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 请求的响应判断</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onload = function()&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            console.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(&#x27;GET&#x27;,&#x27;/list&#x27;,true);</span><br><span class="line">    xhr.send(&#x27;username=James&amp;password=123456&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="responseXML响应XML文档"><a href="#responseXML响应XML文档" class="headerlink" title="responseXML响应XML文档"></a>responseXML响应XML文档</h3><p>概念：返回从服务器接收到的XML文档对象，该属性为只读</p>
<p>文档：和html相似都是标签组成的数据，XML标签是自定义的，复杂，建议使用JSON</p>
<p>l过程如图所示：</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220709110833909.png"></p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>响应数据：类型可以是字符串，XML文档，二进制数据，JSON数据</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>概念：JSON（JavaScirpt Object Notation）是一种轻量级的数据交换格式。它使人们容易的进行阅读和编写。同时也方便了机器的解析和生成。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 单租JSON</span><br><span class="line">&#123;&quot;username&quot;:&quot;James&quot;,&quot;password&quot;:&#x27;123456&#x27;&#125;</span><br><span class="line">// 多组JSON</span><br><span class="line">[</span><br><span class="line">	&#123;&quot;username&quot;:&quot;James&quot;,&quot;password&quot;:&#x27;123456&#x27;&#125;,</span><br><span class="line">	&#123;&quot;username&quot;:&quot;Hero&quot;,&quot;password&quot;:&#x27;111111&#x27;&#125;,</span><br><span class="line">	&#123;&quot;username&quot;:&quot;LISA&quot;,&quot;password&quot;:&#x27;666666&#x27;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<h3 id="JSON规范"><a href="#JSON规范" class="headerlink" title="JSON规范"></a>JSON规范</h3><ul>
<li>key属性和字符串类型值，必须使用双引号。</li>
<li>指的类型范围有限：string，number，object，array，boolean，null ，其他类型不支持。</li>
<li>最后一组数据，不能够添加逗号结束。</li>
</ul>
<p>演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// JSON格式数据</span><br><span class="line"> var json = &#123;</span><br><span class="line">     &quot;username&quot;: &quot;James&quot;,</span><br><span class="line">     &quot;foo&quot;: null</span><br><span class="line"> &#125;;</span><br><span class="line"> // 作为对象，数据很容易拿到数据，但是在后端往浏览器响应数据的时候是字符串类型的JSON，所以需要解析JSON字符串</span><br><span class="line"> console.log(json.username);</span><br><span class="line"></span><br><span class="line"> // 拿到的JSON字符串长这样，没办法通过属性获取到值</span><br><span class="line"> var json = &#x27;&#123;&quot;username&quot;:&quot;James&quot;&#125;&#x27;;</span><br><span class="line"> // 所以要利用JSON的parse方法解析JSON字符串</span><br><span class="line"> json = JSON.parse(json);</span><br><span class="line"> console.log(json.username);</span><br><span class="line"> </span><br><span class="line"> // 如果是多组JSON操作，字符串编辑麻烦可以使用转换</span><br><span class="line"> var json = [</span><br><span class="line">     &#123; &quot;username&quot;: &quot;James&quot;, &quot;password&quot;: &#x27;123456&#x27; &#125;,</span><br><span class="line">     &#123; &quot;username&quot;: &quot;Hero&quot;, &quot;password&quot;: &#x27;111111&#x27; &#125;,</span><br><span class="line">     &#123; &quot;username&quot;: &quot;LISA&quot;, &quot;password&quot;: &#x27;666666&#x27; &#125;</span><br><span class="line"> ];</span><br><span class="line"> // 把引用类型的数据转换为JSON字符串</span><br><span class="line"> // stringify()方法和parse()方法，操作相反。</span><br><span class="line"> json = JSON.stringify(json); </span><br><span class="line"> json = JSON.parse(json);</span><br><span class="line"> console.log(json[2].username);</span><br></pre></td></tr></table></figure>

<p>JSON数据发送请求演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 使用JSON数据，请求传输数据</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onload = function()&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            // 1.输出查看，控制台返回的数据</span><br><span class="line">            // console.log(xhr.responseText);</span><br><span class="line"></span><br><span class="line">            // 2.根据数据获取数据</span><br><span class="line">            var data = JSON.parse(xhr.responseText);</span><br><span class="line">            console.log(data.list[0].username);</span><br><span class="line">            console.log(data.list[0].age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(&#x27;GET&#x27;,&#x27;/list&#x27;,true);</span><br><span class="line">    xhr.send();</span><br></pre></td></tr></table></figure>

<p>接口文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#x27;/list&#x27;, async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.body = &quot;list Data&quot;;</span><br><span class="line"></span><br><span class="line">  // 接收get传输的数据</span><br><span class="line">  // 通过ctx下面有一个request对象的query</span><br><span class="line">  // console.log(ctx.request.query);</span><br><span class="line"></span><br><span class="line">  // 在koa框架中，只要使用&#123;&#125;就可以访问JSON格式数据了“koa自动进行了转换”</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    errcode:0,</span><br><span class="line">    errmsg:&#x27;ok&#x27;,</span><br><span class="line">    list:[</span><br><span class="line">      &#123;&quot;username&quot;: &quot;James&quot;, &quot;age&quot;: &#x27;30&#x27;,gender:&#x27;男&#x27;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>JSON：一种轻量级的数据交换格式，比XML要简单，灵活，高效。<br>JSON规范：双引号，类型限制，逗号<br>JSON方法：JSON.stringify( )   JSON.parse( )    前后端数据通信的便捷转换神器。</p>
<h1 id="响应JSON数据到页面"><a href="#响应JSON数据到页面" class="headerlink" title="响应JSON数据到页面"></a>响应JSON数据到页面</h1><h2 id="1-DOM方式"><a href="#1-DOM方式" class="headerlink" title="1.DOM方式"></a>1.DOM方式</h2><p>DOM是HTML文档的编程接口。DOM将文档解析为一个由节点和对象组成的结构集合，也叫DOM树。简言之它会将web页面和脚本或程序语言连接起来。<br>操作语法：节点的操作<br>演示：<br>html文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;table border=&quot;1&quot;&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">                &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">                &lt;th&gt;性别&lt;/th&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/tbody&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 响应数据到页面</span><br><span class="line">    // 方式一：DOM</span><br><span class="line">    var tbody = document.querySelector(&#x27;tbody&#x27;);</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onload = function()&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            // 拿到数据进行解析</span><br><span class="line">            var data = JSON.parse(xhr.responseText);</span><br><span class="line">            // 遍历数据数组</span><br><span class="line">            for(var i = 0;i&lt;data.list.length;i++)&#123;</span><br><span class="line">                var tr = document.createElement(&#x27;tr&#x27;);</span><br><span class="line">                // 遍历数组中的对象</span><br><span class="line">                for(var key in data.list[i])&#123;</span><br><span class="line">                    var td = document.createElement(&#x27;td&#x27;);</span><br><span class="line">                    td.innerHTML = data.list[i][key];</span><br><span class="line">                    tr.append(td);</span><br><span class="line">                &#125;</span><br><span class="line">                tbody.append(tr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(&#x27;GET&#x27;,&#x27;/list&#x27;,true);</span><br><span class="line">    xhr.send();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>接口文件：随意的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#x27;/list&#x27;, async (ctx, next)=&gt;&#123;</span><br><span class="line">  ctx.body = &quot;list Data&quot;;</span><br><span class="line"></span><br><span class="line">  // 接收get传输的数据</span><br><span class="line">  // 通过ctx下面有一个request对象的query</span><br><span class="line">  // console.log(ctx.request.query);</span><br><span class="line"></span><br><span class="line">  // 在koa框架中，只要使用&#123;&#125;就可以访问JSON格式数据了“koa自动进行了转换”</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    errcode:0,</span><br><span class="line">    errmsg:&#x27;ok&#x27;,</span><br><span class="line">    list:[</span><br><span class="line">      &#123;&quot;username&quot;: &quot;James&quot;, &quot;age&quot;: &#x27;30&#x27;,gender:&#x27;男&#x27;&#125;,</span><br><span class="line">      &#123;&quot;username&quot;: &quot;LASA&quot;, &quot;age&quot;: &#x27;20&#x27;,gender:&#x27;女&#x27;&#125;,</span><br><span class="line">      &#123;&quot;username&quot;: &quot;TOM&quot;, &quot;age&quot;: &#x27;28&#x27;,gender:&#x27;男&#x27;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-模板拼接字符串"><a href="#2-模板拼接字符串" class="headerlink" title="2.模板拼接字符串"></a>2.模板拼接字符串</h2><p>概念：末班字符串使用反引号来代替普通字符串的双引号和单引号，可以使用多行字符串和字符串插值功能，直接在字符串中渲染数据变量，ES6提供的语法。<br>例如：<br>    var username = ‘James’;<br>    var info = ‘Mm name is ${username}’;<br>演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 方式二：末班字符串</span><br><span class="line">    var tbody = document.querySelector(&#x27;tbody&#x27;);</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onload = function () &#123;</span><br><span class="line">        if (xhr.status == 200) &#123;</span><br><span class="line">            // 拿到数据进行解析</span><br><span class="line">            var data = JSON.parse(xhr.responseText);</span><br><span class="line">            // 渲染数据</span><br><span class="line">            // tbody.innerHTML = data.list.map((item,i)=&gt;&#123;</span><br><span class="line">            //     return `</span><br><span class="line">            //         &lt;tr&gt;</span><br><span class="line">            //             &lt;td&gt;$&#123;item.username&#125;&lt;/td&gt;</span><br><span class="line">            //             &lt;td&gt;$&#123;item.age&#125;&lt;/td&gt;</span><br><span class="line">            //             &lt;td&gt;$&#123;item.gender&#125;&lt;/td&gt;</span><br><span class="line">            //         &lt;/tr&gt;</span><br><span class="line">            //     `</span><br><span class="line">            // &#125;).join(&#x27; &#x27;);</span><br><span class="line">            for (var i = 0; i &lt; data.list.length; i++) &#123;</span><br><span class="line">                tbody.innerHTML += `</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;data.list[i].username&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;data.list[i].age&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;data.list[i].gender&#125;&lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                `</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(&#x27;GET&#x27;, &#x27;/list&#x27;, true);</span><br><span class="line">    xhr.send();</span><br></pre></td></tr></table></figure>
<p>注意：这种方式渲染，比较繁琐，因为逻辑代码和视图层混合在一起使用了，最好把逻辑代码和视图层分离写法。</p>
<h2 id="3-前端模板引擎的使用"><a href="#3-前端模板引擎的使用" class="headerlink" title="3.前端模板引擎的使用"></a>3.前端模板引擎的使用</h2><p>概念：模板引擎可以让(网站)程序实现界面与数据分离，业务代码与逻辑代码的分离，提升开发效率，良好的设计也提高了代码的复用性。<br>网站资源：art-template ，mustache ，ejs ，Handlebar.js , jQuery tmpl  ……<br>** art-template 模板引擎使用 **<br>1.下载模板引擎js文件放置到项目<br><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220709151406895.png"><br>2.在html文件内引入JS文件<br>3.改写JS代码<br>演示：<br>3.1 添加模板引擎代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在js上方添加莫版块： id名随意。 type:是固定的表示使用自定义模板--&gt;</span><br><span class="line">&lt;script  id = &quot;tpl-tibody&quot;  type = &quot;text/html&quot; &gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.2 js文件的语法使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 方式三：使用模板引擎</span><br><span class="line">  var tbody = document.querySelector(&#x27;tbody&#x27;);</span><br><span class="line">  var xhr = new XMLHttpRequest();</span><br><span class="line">  xhr.onload = function () &#123;</span><br><span class="line">      if (xhr.status == 200) &#123;</span><br><span class="line">          // 拿到数据进行解析</span><br><span class="line">          var data = JSON.parse(xhr.responseText);</span><br><span class="line">          // 根据模板名称渲染模板</span><br><span class="line">          // 参数1:模板引擎的id名。参数2数据名</span><br><span class="line">          tbody.innerHTML = template(&#x27;tpl-tibody&#x27;, data);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.open(&#x27;GET&#x27;, &#x27;/list&#x27;, true);</span><br><span class="line">  xhr.send();</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220709152314909.png"><br>3.3 模板中数据渲染逻辑处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=&quot;tpl-tibody&quot; type=&quot;text/html&quot;&gt;</span><br><span class="line">    &#123;&#123; each list&#125;&#125;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&#123;&#123; $value.username &#125;&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&#123;&#123; $value.age &#125;&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&#123;&#123; $value.gender &#125;&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;!-- 代表结束，否则会报错 --&gt;</span><br><span class="line">    &#123;&#123; /each&#125;&#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>如何把JSON数据渲染到页面：DOM操作，拼接模板字符串，前端模板引擎，或后面学习的vue，React等框架。</p>
<h1 id="发送JSON数据"><a href="#发送JSON数据" class="headerlink" title="发送JSON数据"></a>发送JSON数据</h1><p>概念：GET请求不能发送JSON数据，POST请求可以发送JSON数据<br>POST通过修改请求头信息，进行JSON数据发送，通过setRequestHeader( )方法进行设置。<br>例如：<br>    xhr.open(‘POST’,’<a target="_blank" rel="noopener" href="http://localhost/list2&#39;,true">http://localhost/list2&#39;,true</a>);<br>    xhr.serRequestHeader(‘Content-Type’,’application/json’);<br>    xhr.send(JSON.stringify({“username”:”James”,”age:30}));<br>演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// post请求发送JSON数据</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.onload = function () &#123;</span><br><span class="line">    if (xhr.status == 200) &#123;</span><br><span class="line">        console.log(&quot;请求发送&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&#x27;POST&#x27;, &#x27;/list2&#x27;, true);</span><br><span class="line">xhr.setRequestHeader(&#x27;Conten-Type&#x27;,&#x27;application/json&#x27;);</span><br><span class="line">xhr.send(JSON.stringify(&#123;&quot;username&quot;:&quot;LISA&quot;,&quot;agqe&quot;:&quot;30&quot;&#125;));</span><br></pre></td></tr></table></figure>
<p>接口文件不变</p>
<h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>发送JSON数据：保证了前后端数据格式的统一，方便其前后端操作，并且可以发送更加复杂的数据结构给后端。</p>
<h1 id="API接口文档"><a href="#API接口文档" class="headerlink" title="API接口文档"></a>API接口文档</h1><h3 id="什么是接口文档？"><a href="#什么是接口文档？" class="headerlink" title="什么是接口文档？"></a>什么是接口文档？</h3><p>在项目开发中，web项目的前后端是分离开发的。应用程序的开发，需要由前后端工程师共同定义跌口，编写接口文档，之后大家根据这个接口文档进行开发，到项目结束前都要一直维护。</p>
<h3 id="编写接口文档"><a href="#编写接口文档" class="headerlink" title="编写接口文档"></a>编写接口文档</h3><p>接口文档大概需要编写内容为：接口说明，请求方式，请求URL，请求参数，返回参数等<br>例如：<br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/liveplayer/studio-api.html">https://developers.weixin.qq.com/miniprogram/dev/framework/liveplayer/studio-api.html</a></p>
<h1 id="案例：初始化渲染页面"><a href="#案例：初始化渲染页面" class="headerlink" title="案例：初始化渲染页面"></a>案例：初始化渲染页面</h1><ol>
<li><p>体育新闻页进行复制。</p>
</li>
<li><p>删减原来页面内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;header id=&quot;sports-header&quot;&gt;</span><br><span class="line">        腾讯 | 体育</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">    &lt;div id=&quot;loadingDown&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;main id=&quot;sports-main&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ul class=&quot;sports-list&quot;&gt;</span><br><span class="line">                &lt;!-- 待渲染列表 --&gt;</span><br><span class="line">                &lt;!-- &lt;li&gt;</span><br><span class="line">                    &lt;div class=&quot;sports-list-text&quot;&gt;</span><br><span class="line">                        &lt;p&gt;詹姆斯一分半钟拿下6分1盖帽 这就是联盟第一人的水准&lt;/p&gt;</span><br><span class="line">                        &lt;p&gt;&lt;span&gt;50评&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;sports-list-img&quot;&gt;</span><br><span class="line">                        &lt;img src=&quot;./images/James1.webp&quot; alt=&quot;&quot;&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/li&gt; --&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">            &lt;div id=&quot;loadingUp&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div id=&quot;loading&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/main&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>保留模板，页面与逻辑分离( 可用其他渲染方式 )。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./javascripts/template-web.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>根据API接口文档编辑代码(前后端同时编写)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var sportsList = document.querySelector(&#x27;.sports-list&#x27;);</span><br><span class="line">    // 创建对象</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    // 添加onload事件，监听请求是否完成，触发则完成</span><br><span class="line">    xhr.onload = function () &#123;</span><br><span class="line">        // 判断响应的HTTP状态码 是否为200</span><br><span class="line">        if (xhr.status == 200) &#123;</span><br><span class="line">            // 获取响应字符串</span><br><span class="line">            console.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 发送POST请求，路径为list3，异步的</span><br><span class="line">    xhr.open(&#x27;POST&#x27;,&#x27;/list3&#x27;,true);</span><br><span class="line">    // 请求参数是一个json格式的，需要设置Conten-Type</span><br><span class="line">    xhr.setRequestHeader(&#x27;Conten-Type&#x27;,&#x27;application/json&#x27;);</span><br><span class="line">    // 发送数据把数据转换为JSON字符串</span><br><span class="line">    xhr.send(JSON.stringify(&#123;&quot;page&quot;:0,&quot;count&quot;:10&#125;));</span><br></pre></td></tr></table></figure></li>
<li><p>刷新浏览器，查看控制台状态，返回404“ 没有响应内容”，可以在终端查看返回的数据</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220711115412652.png"></p>
</li>
<li><p>编写后端内容（错误码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">router.post(&#x27;/list3&#x27;, async (ctx,next)=&gt;&#123;</span><br><span class="line">  // 编辑错误信息,参数集合</span><br><span class="line">  var args = [</span><br><span class="line">    &#123; field:&#x27;page&#x27;,type:&#x27;number&#x27;&#125;,</span><br><span class="line">    &#123; field:&#x27;count&#x27;,type:&#x27;number&#x27;&#125;</span><br><span class="line">  ];</span><br><span class="line">  var body = ctx.request.body;</span><br><span class="line">  for(var i = 0;i&lt;args.length;i++)&#123;</span><br><span class="line">    var item = args[i];</span><br><span class="line">    // Object.keys获取body的对象的，includes判断是否包含指定的字符串</span><br><span class="line">    // ！取反</span><br><span class="line">    if(!Object.keys(body).includes(item.field))&#123;</span><br><span class="line">      ctx.body = &#123;</span><br><span class="line">        errcode : -1,</span><br><span class="line">        errmsg:&#x27;参数个数错误&#x27;</span><br><span class="line">      &#125;;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      // 判断参数类型</span><br><span class="line">      if( typeof body[item.field] != item.type)&#123;</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          errcode : -2,</span><br><span class="line">          errmsg:&#x27;参数类型错误&#x27;</span><br><span class="line">        &#125;;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.body = &quot;ok&quot;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用json文件渲染数据</p>
<p>新建data文件夹，把 list.json文件放进来 （注意：这里未操作数据库，json文件内为假数据，写死的数据）</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220711161138863.png"></p>
<p><strong>响应json文件内的数据</strong></p>
<ul>
<li><p>先在接口文件中的顶部定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// node.js 提供的内置模块fs，可以读取文件</span><br><span class="line"></span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>后端获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> // ctx.body = &quot;ok&quot;;</span><br><span class="line">// 字符串类型的数据</span><br><span class="line"> var data = fs.readFileSync(&#x27;./data/list.json&#x27;); //路径都是相对于根路径查找</span><br><span class="line"> // 转换为数据类型的</span><br><span class="line"> data = JSON.parse(data);</span><br><span class="line"> var list = data.splice(body.page * body.count , body.count);</span><br><span class="line">     </span><br><span class="line"> ctx.body = &#123;</span><br><span class="line">   errcode : -0,</span><br><span class="line">   errmsg:&#x27;ok&#x27;,</span><br><span class="line">   list</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>刷新浏览器，工具栏查看数据</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220711163127669.png"></p>
</li>
<li><p>拿到数据后就渲染到前台</p>
<p>1.1 先写引擎模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id=&quot;tpl-sportsList&quot; type=&quot;text/html&quot;&gt;</span><br><span class="line">    &#123;&#123; each list &#125;&#125;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;div class=&quot;sports-list-text&quot;&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &#123;&#123; $value.title &#125;&#125;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &lt;span&gt;&#123;&#123; $value.comment &#125;&#125;评&lt;/span&gt;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;sports-list-img&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;&#123;&#123; $value.img &#125;&#125;&quot; alt=&quot;&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &#123;&#123; /each &#125;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>1.2 渲染数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 添加onload事件，监听请求是否完成，触发则完成</span><br><span class="line">    xhr.onload = function () &#123;</span><br><span class="line">        // 判断响应的HTTP状态码 是否为200</span><br><span class="line">        if (xhr.status == 200) &#123;</span><br><span class="line">            // 获取响应字符串</span><br><span class="line">            // console.log(xhr.responseText);</span><br><span class="line">            // 转换为数据格式</span><br><span class="line">            var data = JSON.parse(xhr.responseText)</span><br><span class="line">            // 使用模板引擎渲染数据</span><br><span class="line">            if(data.errcode == 0)&#123;</span><br><span class="line">                sportsList.innerHTML = template(&#x27;tpl-sportsList&#x27;,data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="渲染成功-886"><a href="#渲染成功-886" class="headerlink" title="渲染成功 886"></a>渲染成功 886</h1>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/lijinshuai_blog/2020/05/01/%E4%BD%9C%E7%94%A8%E5%9F%9F,%E4%B8%8A%E4%B8%8B%E6%96%87,%E9%97%AD%E5%8C%85,%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">
                作用域链、执行上下文、垃圾回收、闭包
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2020-05-01</span>
            
            
            
                <span class="category">
                    <a href="/lijinshuai_blog/categories/JavaScript/">JavaScript</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <h4 id="作用域链、执行上下文、垃圾回收、闭包"><a href="#作用域链、执行上下文、垃圾回收、闭包" class="headerlink" title="作用域链、执行上下文、垃圾回收、闭包"></a>作用域链、执行上下文、垃圾回收、闭包</h4><h2 id="1、作用域"><a href="#1、作用域" class="headerlink" title="1、作用域"></a>1、作用域</h2><h3 id="1-1-什么是作用域"><a href="#1-1-什么是作用域" class="headerlink" title="1.1 什么是作用域"></a>1.1 什么是作用域</h3><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。我们先来看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outFun2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">&quot;内层变量2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">outFun2</span>();<span class="comment">//要先执行这个函数，否则根本不知道里面是啥</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inVariable); <span class="comment">// Uncaught ReferenceError: inVariable is not defined</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以体会到作用域的概念，变量 inVariable 在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p>
<p><strong>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</strong>。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。</p>
<h3 id="1-2-全局作用域和函数作用域"><a href="#1-2-全局作用域和函数作用域" class="headerlink" title="1.2 全局作用域和函数作用域"></a>1.2 全局作用域和函数作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
<ul>
<li><p>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var outVariable = &quot;我是最外层变量&quot;; //最外层变量</span><br><span class="line">function outFun() &#123; //最外层函数</span><br><span class="line">    var inVariable = &quot;内层变量&quot;;</span><br><span class="line">    function innerFun() &#123; //内层函数</span><br><span class="line">        console.log(inVariable);</span><br><span class="line">    &#125;</span><br><span class="line">    innerFun();</span><br><span class="line">&#125;</span><br><span class="line">console.log(outVariable); //我是最外层变量</span><br><span class="line">outFun(); //最外层函数</span><br><span class="line">console.log(inVariable); //inVariable is not defined</span><br><span class="line">innerFun(); //innerFun is not defined</span><br></pre></td></tr></table></figure></li>
<li><p>所有末定义直接赋值的变量自动声明为拥有全局作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outFun2() &#123;</span><br><span class="line">    variable = &quot;未定义直接赋值的变量&quot;;</span><br><span class="line">    var inVariable2 = &quot;内层变量2&quot;;</span><br><span class="line">&#125;</span><br><span class="line">outFun2();//要先执行这个函数，否则根本不知道里面是啥</span><br><span class="line">console.log(variable); //未定义直接赋值的变量</span><br><span class="line">console.log(inVariable2); //inVariable2 is not defined</span><br></pre></td></tr></table></figure></li>
<li><p>所有 window 对象的属性拥有全局作用域</p>
<p>一般情况下，window 对象的内置属性都拥有全局作用域，例如 window.name、window.location、window.top 等等。</p>
</li>
</ul>
<p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。</p>
<p>函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。</p>
<p><strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong>。</p>
<h3 id="1-3-作用域链"><a href="#1-3-作用域链" class="headerlink" title="1.3 作用域链"></a>1.3 作用域链</h3><h4 id="1-3-1-什么是自由变量"><a href="#1-3-1-什么是自由变量" class="headerlink" title="1.3.1 什么是自由变量"></a>1.3.1 什么是自由变量</h4><p>首先认识一下什么叫做 <strong>自由变量</strong> 。如下代码中，<code>console.log(a)</code>要得到 a 变量，但是在当前的作用域中没有定义 a（可对比一下 b）。<strong>当前作用域没有定义的变量，这成为 自由变量</strong> 。自由变量的值如何得到 —— 向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 100</span><br><span class="line">function fn() &#123;</span><br><span class="line">    var b = 200</span><br><span class="line">    console.log(a) // 这里的a在这里就是一个自由变量</span><br><span class="line">    console.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-什么是作用域链"><a href="#1-3-2-什么是作用域链" class="headerlink" title="1.3.2 什么是作用域链"></a>1.3.2 什么是作用域链</h4><p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = 100</span><br><span class="line">function F1() &#123;</span><br><span class="line">    var b = 200</span><br><span class="line">    function F2() &#123;</span><br><span class="line">        var c = 300</span><br><span class="line">        console.log(a) // 自由变量，顺作用域链向父作用域找</span><br><span class="line">        console.log(b) // 自由变量，顺作用域链向父作用域找</span><br><span class="line">        console.log(c) // 本作用域的变量</span><br><span class="line">    &#125;</span><br><span class="line">    F2()</span><br><span class="line">&#125;</span><br><span class="line">F1()</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-关于自由变量的取值"><a href="#1-3-3-关于自由变量的取值" class="headerlink" title="1.3.3 关于自由变量的取值"></a>1.3.3 关于自由变量的取值</h4><p>关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x = 10</span><br><span class="line">function fn() &#123;</span><br><span class="line">  console.log(x)</span><br><span class="line">&#125;</span><br><span class="line">function show(f) &#123;</span><br><span class="line">  var x = 20</span><br><span class="line">  (function() &#123;</span><br><span class="line">    f() //10，而不是20</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">show(fn)</span><br></pre></td></tr></table></figure>

<p>在 fn 函数中，<strong>取自由变量 x 的值时，要到哪个作用域中取？——要到创建 fn 函数的那个作用域中取</strong>，<strong>无论 fn 函数将在哪里调用</strong>。</p>
<p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切:**要到创建这个函数的那个域”。</p>
<p>作用域中取值,这里强调的是“创建”，而不是“调用”**，切记切记。</p>
<h2 id="2、执行上下文栈"><a href="#2、执行上下文栈" class="headerlink" title="2、执行上下文栈"></a>2、执行上下文栈</h2><h3 id="2-1-执行上下文（Execution-Context）"><a href="#2-1-执行上下文（Execution-Context）" class="headerlink" title="2.1 执行上下文（Execution Context）"></a>2.1 执行上下文（Execution Context）</h3><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p>
<p>执行上下文（可执行代码段）总共有三种类型：</p>
<ul>
<li><p><strong>全局执行上下文（全局代码）</strong>：不在任何函数中的代码都位于全局执行上下文中，只有一个，浏览器中的全局对象就是 window 对象，<code>this</code> 指向这个全局对象。</p>
</li>
<li><p><strong>函数执行上下文（函数体）</strong>：只有调用函数时，才会为该函数创建一个新的执行上下文，可以存在无数个，每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤。</p>
</li>
<li><p><strong>Eval 函数执行上下文（eval代码）</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(&quot;alert(123)&quot;);</span><br></pre></td></tr></table></figure>

<p>执行上下文又包括三个生命周期阶段：<strong>创建阶段→执行阶段→回收阶段</strong></p>
<p><strong>1.创建阶段</strong></p>
<p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p>
<ul>
<li>创建变量对象(Variable object，VO)：首先初始化函数的参数arguments，提升函数声明和变量声明。</li>
<li>创建作用域链（Scope  Chain）：在执行上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li>
<li>确定this指向：包括多种情况。</li>
</ul>
<p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS  是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p>
<p>另外，一个函数在被执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过函数执行上下文中会多出this arguments和函数的参数。</p>
<p>全局代码的上下文环境数据内容为：</p>
<table>
<thead>
<tr>
<th>普通变量（包括函数表达式）， 如： var a = 10;</th>
<th>声明（默认赋值为undefined）</th>
</tr>
</thead>
<tbody><tr>
<td>函数声明， 如： function fn() { }</td>
<td>赋值</td>
</tr>
<tr>
<td>this</td>
<td>赋值</td>
</tr>
</tbody></table>
<p>如果代码段是函数体，那么在此基础上需要附加：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>赋值</th>
</tr>
</thead>
<tbody><tr>
<td>arguments</td>
<td>赋值</td>
</tr>
<tr>
<td>自由变量的取值作用域</td>
<td>赋值</td>
</tr>
</tbody></table>
<p><strong>2.执行阶段</strong></p>
<p>进入执行上下文、执行代码</p>
<p><strong>3.回收阶段</strong></p>
<p>执行完毕后执行上下文出栈等待垃圾回收</p>
<p><img src="C:%5Ctypro-images%5Cv2-941bda734e6c6679f3528e8a1343ebd7_1440w.jpg"></p>
<h3 id="2-2-栈（stack）"><a href="#2-2-栈（stack）" class="headerlink" title="2.2 栈（stack）"></a>2.2 栈（stack）</h3><p><strong>栈是一种操作受限的线性表只允许从一端插入和删除数据。</strong>栈有两种存储方式，即线性存储和链接存储（链表）。栈的一个最重要的特征就是<strong>栈的插入和删除只能在栈顶进行，所以每次删除的元素都是最后进栈的元素，故栈也被称为先进后出表。</strong>每个栈都有一个栈顶指针，它初始值为-1，且总是指向最后一个入栈的元素，<strong>栈有两种处理方式，即进栈（push）和出栈（pop）</strong>，因为在进栈只需要移动一个变量存储空间，所以它的时间复杂度为O(1)，但是对于出栈分两种情况，栈未满时，时间复杂度也为O(1)，但是当栈满时，需要重新分配内存，并移动栈内所有数据，所以此时的时间复杂度为O(n)。</p>
<p><img src="C:%5Ctypro-images%5C20180917000315795"></p>
<h3 id="2-3-执行上下文栈（Execution-Context-Stack）"><a href="#2-3-执行上下文栈（Execution-Context-Stack）" class="headerlink" title="2.3 执行上下文栈（Execution Context Stack）"></a>2.3 执行上下文栈（Execution Context Stack）</h3><p>假如我们写的函数多了，每次调用函数时都创建一个新的执行上下文，如何管理创建的那么多执行上下文呢？</p>
<p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文，具有 LIFO（后进先出）的栈结构，用于存储在代码执行期间创建的所有执行上下文。</p>
<p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个<strong>新的函数</strong>执行上下文并Push到当前执行栈的顶部，浏览器的JS执行引擎总是访问栈顶的执行上下文。</p>
<p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的<strong>函数</strong>执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的<strong>下一个</strong>执行上下文，最终移回到<strong>全局</strong>执行上下文，全局上下文只有唯一的一个，它在浏览器关闭时Pop出。</p>
<h2 id="3、js内存泄露以及垃圾回收机制"><a href="#3、js内存泄露以及垃圾回收机制" class="headerlink" title="3、js内存泄露以及垃圾回收机制"></a>3、js内存泄露以及垃圾回收机制</h2><h3 id="3-1-什么是内存泄漏？"><a href="#3-1-什么是内存泄漏？" class="headerlink" title="3.1 什么是内存泄漏？"></a>3.1 什么是内存泄漏？</h3><p><strong>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</strong></p>
<p>程序的运行需要内存，只要程序提出要求，操作系统或者运行是就必须供给内存。</p>
<p>对于持续运行的服务进程，必须及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>
<p>不再用到的内存，没有及时释放，就叫做内存泄漏。</p>
<p>有些语言（比如c语言）必须手动释放内存，程序员负责内存管理。</p>
<p>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”。</p>
<h3 id="3-2-垃圾回收机制"><a href="#3-2-垃圾回收机制" class="headerlink" title="3.2 垃圾回收机制"></a>3.2 垃圾回收机制</h3><p>JS自带一套内存管理引擎，负责创建对象、销毁对象，以及垃圾回收。</p>
<p>垃圾回收机制主要是由一个叫垃圾收集器（garbage collector，简称GC）的后台进程负责监控、清理对象，并及时回收空闲内存。</p>
<h4 id="3-2-1-可达性（Reachability）"><a href="#3-2-1-可达性（Reachability）" class="headerlink" title="3.2.1 可达性（Reachability）"></a>3.2.1 可达性（Reachability）</h4><p>GC的最主要职责是监控数据的<strong>可达性（reachability）</strong>；哪些数据是所谓的<strong>可达的</strong>呢？</p>
<ol>
<li>所有显示调用，被称为<code>根</code>，包括<ul>
<li>全局对象</li>
<li>正被调用的函数的局部变量和参数</li>
<li>相关嵌套函数里的变量和参数</li>
<li>其他（引擎内部调用的一些变量）</li>
</ul>
</li>
<li>所有从根引用或引用链访问的对象</li>
</ol>
<p>举个简单的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let user = &#123;</span><br><span class="line">    name: &#x27;Onion&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里全局变量user指向内存里的对象<code>&#123;name: &#39;Onion&#39;&#125;</code>，我们称其为引用。这时对象Onion（以下均以名字简称）是所谓<strong>可达的</strong>。</p>
<p>将user置为null后，引用丢失，Onion对象就变成不可达了。最终GC会将它从内存中清除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = null</span><br></pre></td></tr></table></figure>

<p>再举一个复杂一点的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function marry(man, woman) &#123;</span><br><span class="line">  woman.husband = man;</span><br><span class="line">  man.wife = woman;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    father: man,</span><br><span class="line">    mother: woman,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let family = marry(&#123;</span><br><span class="line">  name: &quot;Onion&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  name: &quot;Garlic&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在我们删除一些对Onion的引用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete family.father</span><br><span class="line">delete family.mother.husband</span><br></pre></td></tr></table></figure>



<h4 id="3-2-2-“-标记-清除-“算法"><a href="#3-2-2-“-标记-清除-“算法" class="headerlink" title="3.2.2 “ 标记-清除 “算法"></a>3.2.2 “ 标记-清除 “算法</h4><p>基本的垃圾回收算法称为<strong>“标记-清除”</strong>，定期执行以下“垃圾回收”步骤:</p>
<ul>
<li>垃圾回收器获取根并<strong>“标记”</strong>(记住)它们。</li>
<li>然后它访问并“标记”所有来自它们的引用。</li>
<li>然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。</li>
<li>以此类推，直到有未访问的引用(可以从根访问)为止。</li>
<li>除标记的对象外，所有对象都被删除。</li>
</ul>
<p>我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看<strong>“标记并清除”</strong>垃圾回收器如何处理它。</p>
<p>第一步标记根</p>
<p>然后标记他们的引用</p>
<p>以及子孙代的引用:</p>
<p>现在进程中不能访问的对象被认为是不可访问的，将被删除:</p>
<p>这就是垃圾收集的工作原理。</p>
<p>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>
<h4 id="3-2-3-引用计数算法"><a href="#3-2-3-引用计数算法" class="headerlink" title="3.2.3 引用计数算法"></a>3.2.3 引用计数算法</h4><p>另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。</p>
<p>当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另外一个变量，则该值得引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成  0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那  些引用次数为零的值所占用的内存。 </p>
<p>语言引擎有一张”引用表”，保存了内存里面所有资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。</p>
<p><img src="C:%5Ctypro-images%5Cbg2017041703.png" alt="img"></p>
<p>上图中，左下角的两个值，没有任何引用，所以可以释放。</p>
<p>如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3,4];  //1 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>

<p>上面的代码中，数组[1,2,3,4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它是会持续占用内存。</p>
<p>如果增加一行代码，解除arr对[1,2,3,4]引用，这块内存就可以被垃圾回收机制释放了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3,4];</span><br><span class="line"></span><br><span class="line">console.log(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">arr = null;</span><br></pre></td></tr></table></figure>

<p>上面代码中，arr重置为null，就解除了对[1，2，3，4]的引用，引用次数变成了0，内存就可以释放出来了。</p>
<p>及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。</p>
<p>最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。</p>
<p>ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。</p>
<p>下面以 WeakMap 为例，看看它是怎么解决内存泄漏的。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const wm = new WeakMap();</span><br><span class="line"></span><br><span class="line">const element = document.getElementById(&#x27;example&#x27;);</span><br><span class="line"></span><br><span class="line">wm.set(element, &#x27;some information&#x27;);</span><br><span class="line"></span><br><span class="line">wm.get(element) // &quot;some information&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>
<p>也就是说，DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p>
<p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p>
<h3 id="3-3-常见的内存泄露"><a href="#3-3-常见的内存泄露" class="headerlink" title="3.3 常见的内存泄露"></a>3.3 常见的内存泄露</h3><h4 id="3-3-1-意外的全局变量"><a href="#3-3-1-意外的全局变量" class="headerlink" title="3.3.1 意外的全局变量"></a>3.3.1 意外的全局变量</h4><p><strong>意外的全局变量</strong></p>
<p>JavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 <code>window</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123; </span><br><span class="line"></span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>真相是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123; </span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">bar</span> = <span class="string">&quot;this is an explicit global variable&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>函数 <code>foo</code> 内部忘记使用 <code>var</code> ，意外创建了一个全局变量。</p>
<p>解决办法：    在 JavaScript 文件头部加上 <code>&#39;use strict&#39;</code>，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。”use strict” 的目的是指定代码在严格条件下执行。严格模式下你不能使用未声明的变量。</p>
<h4 id="3-3-2-被遗忘的计时器或回调函数"><a href="#3-3-2-被遗忘的计时器或回调函数" class="headerlink" title="3.3.2 被遗忘的计时器或回调函数"></a>3.3.2 被遗忘的计时器或回调函数</h4><p>在 JavaScript 中使用 <code>setInterval</code> 非常平常。一段常见的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = <span class="title function_">getData</span>(); </span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;Node&#x27;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node) &#123; </span><br><span class="line">        node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;, <span class="number">1000</span>); </span><br></pre></td></tr></table></figure>

<p>此例说明了什么：与节点或数据关联的计时器不再需要，<code>node</code> 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，<code>someResource</code> 如果存储了大量的数据，也是无法被回收的。</p>
<h4 id="3-3-3-脱离-DOM-的引用"><a href="#3-3-3-脱离-DOM-的引用" class="headerlink" title="3.3.3 脱离 DOM 的引用"></a>3.3.3 脱离 DOM 的引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var elements = &#123;     </span><br><span class="line">	button: document.getElementById(&#x27;button&#x27;),     </span><br><span class="line">	image: document.getElementById(&#x27;img&#x27;),     </span><br><span class="line">	text: document.getElementById(&#x27;text&#x27;) </span><br><span class="line">&#125;; </span><br><span class="line">function removeButton() &#123; </span><br><span class="line">    // 按钮是 body 的后代元素 </span><br><span class="line">    document.body.removeChild(document.getElementById(&#x27;button&#x27;)); </span><br><span class="line">    // 此时，仍旧存在一个全局的 #button 的引用 </span><br><span class="line">    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="3-3-4-闭包"><a href="#3-3-4-闭包" class="headerlink" title="3.3.4 闭包"></a>3.3.4 闭包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var theThing = null; </span><br><span class="line">var replaceThing = function () &#123;   </span><br><span class="line">	var originalThing = theThing;   </span><br><span class="line">	var unused = function () &#123;     </span><br><span class="line">		if (originalThing)       </span><br><span class="line">			console.log(&quot;hi&quot;);   </span><br><span class="line">	&#125;;    </span><br><span class="line">	theThing = &#123;     </span><br><span class="line">		longStr: new Array(1000000).join(&#x27;*&#x27;),    </span><br><span class="line">		someMethod: function () &#123;       </span><br><span class="line">			console.log(&quot;hello&quot;);    </span><br><span class="line">		&#125;   </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;; </span><br><span class="line">setInterval(replaceThing, 1000); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">代码片段做了一件事情：每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。思绪混乱了吗？最重要的事情是，闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。本质上，闭包的链表已经创建，每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄露。</span><br><span class="line">在 replaceThing 的最后添加 originalThing = null 。</span><br></pre></td></tr></table></figure>

<h2 id="4、闭包"><a href="#4、闭包" class="headerlink" title="4、闭包"></a>4、闭包</h2><p>js的作用域分两种，全局和局部，基于我们所熟悉的作用域链相关知识，我们知道在js作用域环境中访问变量的权利是由内向外的，内部作用域可以获得当前作用域下的变量并且可以获得当前包含当前作用域的外层作用域下的变量，反之则不能，也就是说在外层作用域下无法获取内层作用域下的变量，同样在不同的函数作用域中也是不能相互访问彼此变量的，那么我们想在一个函数内部也有限权访问另一个函数内部的变量该怎么办呢？闭包就是用来解决这一需求的，闭包的本质就是在一个函数内部创建另一个函数。</p>
<p><strong>闭包有3个特性：</strong></p>
<p><strong>①函数嵌套函数</strong></p>
<p><strong>②函数内部可以引用函数外部的参数和变量</strong></p>
<p><strong>③参数和变量不会被垃圾回收机制回收</strong></p>
<p><strong>最后总结一下闭包的好处与坏处</strong></p>
<p>好处</p>
<p>①保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突</p>
<p>②在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）</p>
<p>③匿名自执行函数可以减少内存消耗</p>
<p>坏处</p>
<p>①其中一点上面已经有体现了，就是被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；</p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/lijinshuai_blog/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/lijinshuai_blog/page/3/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a target="_blank" rel="noopener" href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/lijinshuai_blog/2021/09/01/this%E6%8C%87%E5%90%91/">this,this指向</a>
            </li>
            
            <li>
                <a class="footer-post" href="/lijinshuai_blog/2021/09/01/webStorage/">webStorage存储数据</a>
            </li>
            
            <li>
                <a class="footer-post" href="/lijinshuai_blog/2021/08/01/ES6%E6%96%B0%E7%89%B9%E6%80%A7/">ES6新特性</a>
            </li>
            
            <li>
                <a class="footer-post" href="/lijinshuai_blog/2021/08/01/event/">event对象</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/lijinshuai_blog/categories/AJAX/">AJAX</a>
        </li>
        
        <li>
            <a class="footer-post" href="/lijinshuai_blog/categories/Javascript/">Javascript</a>
        </li>
        
        <li>
            <a class="footer-post" href="/lijinshuai_blog/categories/ES6/">ES6</a>
        </li>
        
        <li>
            <a class="footer-post" href="/lijinshuai_blog/categories/HHTTP/">HHTTP</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/lijinshuai21">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:3211384452@qq.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/lijinshuai_blog/js/main.js"></script>


<!-- Disqus Comments -->



</body>

</html>